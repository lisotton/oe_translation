<?php

/**
 * @file
 * OpenEuropa Translation module file.
 */

declare(strict_types = 1);

use Drupal\Core\Breadcrumb\Breadcrumb;
use Drupal\Core\Cache\CacheableMetadata;
use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\Sql\SqlContentEntityStorage;
use Drupal\Core\Link;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Url;
use Drupal\oe_translation\ContentEntitySource;
use Drupal\oe_translation\Entity\TranslationRequestInterface;
use Drupal\oe_translation\Entity\TranslationRequestLogInterface;
use Drupal\oe_translation\FieldProcessor\AddressFieldProcessor;
use Drupal\oe_translation\TranslationModerationHandler;
use Drupal\tmgmt_content\DefaultFieldProcessor;

/**
 * Implements hook_theme().
 */
function oe_translation_theme($existing, $type, $theme, $path) {
  return [
    'local_translation_form_element_group' => [
      'render element' => 'element',
    ],
  ];
}

/**
 * Implements hook_entity_type_alter().
 */
function oe_translation_entity_type_alter(array &$entity_types) {
  foreach ($entity_types as $entity_type_id => $entity_type) {
    // Set translator providers.
    if ($entity_type_id === 'node') {
      $translators = [
        'local' => TRUE,
        'remote' => [
          'epoetry',
        ],
      ];
      $entity_type->set('oe_translation_translators', $translators);
    }

    // Change the moderation handler if set to our own override.
    if (!$entity_type->hasHandlerClass('moderation')) {
      continue;
    }

    $entity_type->setHandlerClass('moderation', TranslationModerationHandler::class);
  }
}

/**
 * Implements template_preprocess_node().
 */
function oe_translation_preprocess_node(&$variables) {
  // Ensure that on the TMGMT preview page, we treat the node as the full page
  // display.
  if (\Drupal::service('current_route_match')->getRouteName() !== 'entity.oe_translation_request.preview') {
    return;
  }

  $variables['page'] = TRUE;
}

/**
 * Implements hook_entity_base_field_info_alter().
 */
function oe_translation_entity_base_field_info_alter(&$fields, EntityTypeInterface $entity_type) {
  // We don't want different translations to have different moderation states
  // so we make the moderation state field untranslatable.
  if ($entity_type->id() === 'content_moderation_state') {
    $fields['moderation_state']->setTranslatable(FALSE);
  }
}

/**
 * Implements hook_entity_access().
 */
function oe_translation_entity_access(EntityInterface $entity, $operation, AccountInterface $account) {
  if (!$entity instanceof ContentEntityInterface) {
    return AccessResult::neutral();
  }

  if (!in_array($operation, ['update'])) {
    // @todo , see if we should allow the deletion of translations.
    return AccessResult::neutral();
  }

  /** @var \Drupal\oe_translation\TranslatorProvidersInterface $translator_providers */
  $translator_providers = \Drupal::service('oe_translation.translator_providers');
  if (!$translator_providers->hasTranslators($entity->getEntityType())) {
    return AccessResult::neutral();
  }

  // We do not want translations to be manually edited if they are supported
  // by our translation system.
  if (!$entity->isDefaultTranslation()) {
    return AccessResult::forbidden()->addCacheableDependency($entity);
  }

  return AccessResult::neutral();
}

/**
 * Implements hook_module_implements_alter().
 */
function oe_translation_module_implements_alter(&$implementations, $hook) {
  if ($hook !== 'field_info_alter') {
    return;
  }

  // Make sure that our hook_field_info_alter() fires before TMGMT's.
  if (!isset($implementations['oe_translation'])) {
    return;
  }

  unset($implementations['oe_translation']);
  $implementations['oe_translation'] = FALSE;
}

/**
 * Implements hook_field_info_alter().
 */
function oe_translation_field_info_alter(&$info) {
  if (isset($info['link'])) {
    // For the link field use the default field processor instead of the
    // specific Link one which doesn't allow the translation of the URI.
    $info['link']['tmgmt_field_processor'] = DefaultFieldProcessor::class;
    $info['link']['class'] = \Drupal\oe_translation\LinkItemMultiple::class;
  }

  if (isset($info['address'])) {
    $info['address']['tmgmt_field_processor'] = AddressFieldProcessor::class;
  }
}

/**
 * Implements template_preprocess_local_translation_form_element_group().
 *
 * Template responsible for rendering the local translation form elements.
 */
function oe_translation_preprocess_local_translation_form_element_group(&$variables) {
  $element = $variables['element'];

  $table = [
    '#type' => 'table',
    '#attributes' => [
      'id' => $element['#ajaxid'],
    ],
    '#header' => [
      [
        'data' => implode(' / ', $element['#parent_label']),
        'colspan' => 2,
      ],
    ],
    '#rows' => [],
  ];

  $rows = [];
  $rows[] = [
    [
      'data' => $element['source'],
    ],
    [
      'data' => $element['translation'],
    ],
  ];

  $table['#rows'] = $rows;

  $variables['element'] = $table;
}

/**
 * Implements tmgmt_source_plugin_info_alter().
 */
function oe_translation_tmgmt_source_plugin_info_alter(&$definitions) {
  if (isset($definitions['content'])) {
    // Override the plugin class with ours.
    $definitions['content']['class'] = ContentEntitySource::class;
  }
}

/**
 * Implements hook_tmgmt_translatable_fields_alter().
 */
function oe_translation_tmgmt_translatable_fields_alter(ContentEntityInterface $entity, &$translatable_fields) {
  // Prevent the moderation state to show up as a translatable field. It seems
  // it does even if we mark the base field as non-translatable.
  if (isset($translatable_fields['moderation_state'])) {
    unset($translatable_fields['moderation_state']);
  }
}

/**
 * Implements hook_block_view_BASE_BLOCK_ID_alter() for the Page Header block.
 */
function oe_translation_block_view_oe_theme_helper_page_header_alter(array &$build, $block) {
  $build['#pre_render'][] = function (array $build) {
    // This block is shipped by OpenEuropa Theme and we use this to remove the
    // language switcher from the page header on the entity preview page.
    if (\Drupal::service('current_route_match')->getRouteName() !== 'entity.oe_translation_request.preview') {
      return $build;
    }

    if (isset($build['content']['#language_switcher'])) {
      unset($build['content']['#language_switcher']);
    }

    return $build;
  };
}

/**
 * Implements hook_system_breadcrumb_alter().
 */
function oe_translation_system_breadcrumb_alter(Breadcrumb &$breadcrumb, RouteMatchInterface $route_match, array $context) {
  // Prepare some basic breadcrumb links for the translation request entities.
  if ($route_match->getRouteName() === 'entity.oe_translation_request.canonical') {
    _oe_translation_default_breadcrumb_links($breadcrumb, $route_match, $context);
  }
}

/**
 * Prepares base breadcrumb links for translation pages.
 *
 * @param \Drupal\Core\Breadcrumb\Breadcrumb $breadcrumb
 *   The breadcrumb.
 * @param \Drupal\Core\Routing\RouteMatchInterface $route_match
 *   The route match.
 * @param array $context
 *   The context.
 */
function _oe_translation_default_breadcrumb_links(Breadcrumb &$breadcrumb, RouteMatchInterface $route_match, array $context): void {
  $links = [];
  $links[] = Link::fromTextAndUrl(t('Home'), Url::fromRoute('<front>'));
  /** @var \Drupal\oe_translation\Entity\TranslationRequestInterface $translation_request */
  $translation_request = $route_match->getParameter('oe_translation_request');
  $entity = $translation_request->getContentEntity();
  $links[] = $entity->toLink();
  $links[] = Link::fromTextAndUrl(t('Translate'), $entity->toUrl('drupal:content-translation-overview'));
  $cache = CacheableMetadata::createFromObject($breadcrumb);
  $breadcrumb = new Breadcrumb();
  $breadcrumb->addCacheableDependency($cache);
  $breadcrumb->setLinks($links);
}

/**
 * Creates a table of log messages for the request.
 *
 * @param \Drupal\oe_translation\Entity\TranslationRequestInterface $request
 *   The request.
 *
 * @return array
 *   The log messages.
 */
function _oe_translation_create_request_logs_tables(TranslationRequestInterface $request): array {
  $logs = $request->getLogMessages();
  if (!$logs) {
    return [];
  }

  $table = [
    '#type' => 'table',
    '#attributes' => [
      'class' => ['translation-request-log-messages'],
    ],
    '#header' => [
      '#',
      t('Type'),
      t('Message'),
      t('Date'),
    ],
  ];

  $rows = [];
  $i = 1;
  foreach ($logs as $log) {
    $class_map = [
      TranslationRequestLogInterface::ERROR => 'color-error',
      TranslationRequestLogInterface::WARNING => 'color-warning',
    ];
    $class = $class_map[$log->getType()] ?? NULL;
    $row = [
      $i,
      ucfirst($log->getType()),
      $log->getMessage(),
      \Drupal::service('date.formatter')->format($log->getCreatedTime(), 'short'),
    ];
    $rows[] = [
      'data' => $row,
      'class' => $class ? [$class] : [],
    ];
    $i++;
  }

  $table['#rows'] = $rows;
  return $table;
}

/**
 * Implements hook_entity_operation_alter().
 */
function oe_translation_entity_operation_alter(array &$operations, EntityInterface $entity) {
  if (!$entity instanceof TranslationRequestInterface) {
    return;
  }

  if (isset($operations['edit'])) {
    // Remove the edit operation because for the moment we won't edit requests.
    unset($operations['edit']);
  }

  // Add the extra operations we are defining with our subscriber.
  foreach ($entity->getOperationsLinks()['#links'] as $op => $link) {
    if (!isset($operations[$op])) {
      $operations[$op] = $link;
    }
  }
}

function oe_translation_field_widget_complete_link_default_form_alter(&$field_widget_complete_form, \Drupal\Core\Form\FormStateInterface $form_state, $context) {
  $items = $context['items'];
  foreach ($items as $delta => $item) {
    $field_widget_complete_form['widget'][$delta]['translation_id'] = [
      '#type' => 'hidden',
      '#value' => is_numeric($item->translation_id) ? $item->translation_id : rand(1,1000)
    ];
  }

}


function oe_translation_add_field_property($field_type, $property, $allowed_fields) {
  $manager = Drupal::entityDefinitionUpdateManager();
  $field_map = Drupal::service('entity_field.manager')
    ->getFieldMapByFieldType($field_type);

  foreach ($field_map as $entity_type_id => $fields) {

    foreach (array_keys($fields) as $field_name) {
      if (!in_array($field_name, $allowed_fields)) {
        continue;
      }

      $field_storage_definition = $manager->getFieldStorageDefinition($field_name, $entity_type_id);
      $storage = Drupal::entityTypeManager()->getStorage($entity_type_id);

      if ($storage instanceof SqlContentEntityStorage) {
        $table_mapping = $storage->getTableMapping([
          $field_name => $field_storage_definition,
        ]);
        $table_names = $table_mapping->getDedicatedTableNames();
        $columns = $table_mapping->getColumnNames($field_name);

        foreach ($table_names as $table_name) {
          $field_schema = $field_storage_definition->getSchema();
          if (!isset($field_schema['columns'][$property])) {
            continue;
          }

          $schema = Drupal::database()->schema();
          $field_exists = $schema->fieldExists($table_name, $columns[$property]);
          $table_exists = $schema->tableExists($table_name);

          if (!$field_exists && $table_exists) {
            $schema->addField($table_name, $columns[$property], $field_schema['columns'][$property]);
          }
        }
      }
      $manager->updateFieldStorageDefinition($field_storage_definition);
    }
  }
}
